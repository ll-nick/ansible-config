#!/usr/bin/env nu

let colors = {
    peach: (ansi '#fab387')
    blue: (ansi '#89b4fa')
    green: (ansi '#a6e3a1')
}

def timestamp-file [] {
    let data_home = $env.XDG_DATA_HOME? | default ($env.HOME | path join .local share)
    $data_home | path join dotstk last_update_time.txt
}

def check-update [
    reminder_time: duration
    notify: bool
] {
    if not (timestamp-file | path exists) { return "Timestamp file not found. Run 'dotstk update' to create it." }

    let last_update = timestamp-file | open $in | str trim | into datetime --format "%s"
    let elapsed_time = (date now) - $last_update

    if $notify and ($elapsed_time >= $reminder_time) {
        if (which notify-send | is-empty) {
            print "âš ï¸ notify-send not found - Cannot send notification!"
        } else {
            notify-send "System out of date" $"It's been ($elapsed_time | format duration day) days since your last update!\nConsider running 'dotstk update'."
        }
    }

    $"Last update was ($elapsed_time | format duration day) days ago."
}

def print-title [] {
    let title = r#'
         88                                           88         
         88                ,d                  ,d     88         
         88                88                  88     88         
 ,adPPYb,88   ,adPPYba,  MM88MMM  ,adPPYba,  MM88MMM  88   ,d8   
a8"    `Y88  a8"     "8a   88     I8[    ""    88     88 ,a8"    
8b       88  8b       d8   88      `"Y8ba,     88     8888[      
"8a,   ,d88  "8a,   ,a8"   88,    aa    ]8I    88,    88`"Yba,   
 `"8bbdP"Y8   `"YbbdP"'    "Y888  `"YbbdP"'    "Y888  88   `Y8a  
'#
    print ($colors.peach + $title + (ansi reset))
}

def print-section [title:string] {
    print $"\n($colors.blue)###############################################(ansi reset)"
    print $"($colors.blue)#(ansi reset)  ($colors.green)($title)(ansi reset)"
    print $"($colors.blue)###############################################(ansi reset)\n"

}

# Check when the system was last updated
#
# Can optionally send a desktop notification, if the last update was
# longer ago than the specified reminder time.
def "main check" [
    --reminder-time (-r): duration = 1wk  # Time threshold before warning
    --notify (-n)                         # Send a desktop notification
]: nothing -> string {
    check-update $reminder_time $notify
}


# Update your system and development tools
#
# You one-stop shop for keeping your system and tools up to date.
# Runs updates for the system package manager as well as:
# - Packages installed via mise-en-place
# - Dotfiles via Ansible
# - Tmux plugins via Tmux Plugin Manager (TPM)
# - Neovim plugins via Lazy.nvim
# - Flatpak packages
#
# You may update a single component or run all updates at once.
def "main update" [
    component?: string # If given, update only the specified component (system, mise, dotfiles, tmux, neovim, flatpak)
    --yes (-y) # Assume yes for all prompts
]: nothing -> nothing {
    def confirm-step [prompt_message:string] {
        if $yes {
            return true
        }

        let response = (input $"($prompt_message) \(y/N\): " | str trim | str downcase)
        if $response =~ '^(y|yes)$' { return true }
        print "Skipping..."
        return false
    }

    def update-nixos [] {
        let flake_dir = $env.HOME | path join .config nix
        if not ($flake_dir | path exists) {
            print $"âš ï¸ Nix flake directory not found at ($flake_dir) - Skipping!"
            return
        }

        if (confirm-step "Update Nix flake inputs and rebuild system?") {
            cd $flake_dir
            nix flake update
            sudo nixos-rebuild switch --flake $flake_dir
        }

        if (confirm-step "Garbage collect old NixOS generations and store paths?") {
            sudo nix-collect-garbage --delete-older-than 7d
            nix store gc
        }
    }

    def update-system [] {
        print-section "Updating System Packages ðŸ“¦"

        if (which pacman | is-not-empty) {
            if (confirm-step "Proceed with update via pacman?") {
                if $yes {
                    sudo pacman -Syu --no-confirm
                } else {
                    sudo pacman -Syu
                }
            }
        } else if (which apt | is-not-empty) {
            if (confirm-step "Proceed with update via apt?") {
                sudo apt update
                if $yes {
                    sudo apt upgrade --yes
                } else {
                    sudo apt upgrade
                }
            }
        } else if (which nixos-rebuild | is-not-empty) {
            update-nixos
        } else {
            print "No supported package manager found!"
        }
    }

    def update-mise [] {
        print-section "Updating Mise Packages ðŸ“¦"
        if (which mise | is-empty) {
            print "âš ï¸ mise not installed - Skipping!"
            return
        }

        if (confirm-step "Update mise packages?") {
            $env.MISE_NODE_COMPILE = false
            $env.MISE_PYTHON_COMPILE = false 
            if $yes {
                mise self-update --yes
                mise upgrade --yes
            } else {
                mise self-update
                mise upgrade
            }
        }
    }

    def update-dotfiles [] {
        print-section "Updating Dotfiles ðŸ› ï¸"
        if (which ansible-pull | is-empty) {
            print "âš ï¸ Ansible-pull not installed - Skipping!"
            return
        }

        if (confirm-step "Update dotfiles via Ansible?") {
            ansible-pull -U https://github.com/ll-nick/ansible-config.git
        }
    }

    def update-tmux [] {
        print-section "Updating Tmux Plugins ðŸ”§"

        let tpm_dir = $env.HOME | path join .config tmux plugins tpm
        if not ($tpm_dir | path exists) {
            print "âš ï¸ Tmux Plugin Manager (TPM) Not Found - Skipping!"
            return
        }

        if (confirm-step "Update Tmux plugins?") {
            let update_command = $"($tpm_dir | path join bin update_plugins) all"
            nu -c $update_command
        }
    }

    def update-neovim [] {
        print-section "Updating Neovim Plugins âœ¨"
        if (which nvim | is-empty) {
            print "âš ï¸ Neovim Not Found - Skipping!"
            return
        }

        if (confirm-step "Update Neovim plugins and commit lazy-lock.json?") {
            nvim --headless "+Lazy! sync" +qa
            cd ($env.HOME | path join .config nvim)
            git add lazy-lock.json
            git commit -m "Version bump"
            print "\nChanges:"
            git diff --staged
            if (confirm-step "Push changes to remote?") { git push }
            return
        }

        if (confirm-step "Restore Neovim plugins from lazy-lock.json?") {
            nvim --headless "+Lazy! restore" +qa
        }
    }

    def update-flatpak [] {
        print-section "Updating Flatpak Packages ðŸ“¦"
        if (which flatpak | is-empty) {
            print "âš ï¸ Flatpak not installed - Skipping!"
            return
        }

        if (confirm-step "Update all Flatpak packages?") {
            if $yes {
                flatpak update
            } else {
                flatpak update --yes
            }
        }
    }

    def update-all [] {
        update-system
        update-mise
        update-dotfiles
        update-tmux
        update-neovim
        update-flatpak

        timestamp-file | mkdir ($in | path dirname)
        date now | format date "%s" | save --force (timestamp-file)

        print-section "âœ… All Updates Completed!"
    }
    print-title

    match $component {
        null => update-all,
        "system" => update-system,
        "mise" => update-mise,
        "dotfiles" => update-dotfiles,
        "tmux" => update-tmux,
        "neovim" => update-neovim,
        "flatpak" => update-flatpak,
        _ => {print $"Unknown component: ($component). Valid options are: system, mise, dotfiles, tmux, neovim, flatpak."}
    }
}

# Keep you dotfile stack up to date!
#
# Refer to the subcommands on how to use this tool.
def main []: nothing -> nothing {}

# vim: set ft=nu

