#!/usr/bin/env nu

let DATA_HOME = (
    if ($env.XDG_DATA_HOME? | is-not-empty) {
        $env.XDG_DATA_HOME
    } else {
        $env.HOME | path join .local share
    }
)
let UPDATE_TIMESTAMP = $DATA_HOME | path join dotstk last_update_time.txt
let REMINDER_TIME = 1wk
let NO_CONFIRM = false
let CHECK_REMINDER = false

# Colors
let PEACH = (ansi '#fab387')
let BLUE = (ansi '#89b4fa')
let GREEN = (ansi '#a6e3a1')
let RESET = (ansi reset)

# Reminder Function
def update_reminder [] {
    if not ($UPDATE_TIMESTAMP | path exists) { return }

    let last_update = open $UPDATE_TIMESTAMP | str trim | into datetime --format "%s"
    let current_time = date now
    let elapsed_time = $current_time - $last_update

    if $elapsed_time < $REMINDER_TIME { return }

    notify-send "System out of date" $"It's been ($elapsed_time | format duration day) days since your last update!\nConsider running 'dotstk update'."
}

# Print title
def print_title [] {
    let TITLE = "
 â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  
 â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ 
 â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  
 â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ 
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ   â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ 
"
    print ($PEACH + $TITLE + $RESET)
}

# # Section header
def print_section [title:string] {
    print $"\n($BLUE)###############################################($RESET)"
    print $"($BLUE)#($RESET)  ($GREEN)($title)($RESET)"
    print $"($BLUE)###############################################($RESET)\n"

}
#
# # Confirm step
# def confirm_step [prompt_message:string] {
#     if !$NO_CONFIRM {
#         let response = (read -p "$prompt_message (y/N): " | str trim)
#         if $response =~ '^(y|Y|yes|YES)$' { return true }
#         echo "Skipping..."
#         return false
#     }
#     return true
# }
#
# # Update NixOS
# def update_nixos [] {
#     print_section "Updating NixOS â„ï¸"
#     let flake_dir = $env.HOME + "/.config/nix"
#
#     if !(path $flake_dir | exists) { echo "âš ï¸ Nix flake directory not found at $flake_dir - Skipping!"; return }
#
#     if (confirm_step "Update Nix flake inputs and rebuild system?") {
#         cd $flake_dir {
#             nix flake update
#             sudo nixos-rebuild switch --flake $flake_dir
#         }
#     }
#
#     if (confirm_step "Garbage collect old NixOS generations and store paths?") {
#         sudo nix-collect-garbage --delete-older-than 7d
#         nix store gc
#     }
# }
#
# # Update system packages
# def update_system [] {
#     print_section "Updating System Packages ðŸ“¦"
#
#     if (which pacman) {
#         if (confirm_step "Proceed with update via pacman?") { sudo pacman -Syu --noconfirm }
#     } elif (which apt) {
#         if (confirm_step "Proceed with update via apt?") { sudo apt update && sudo apt upgrade -y }
#     } elif (which nixos-rebuild) {
#         update_nixos
#     } else {
#         echo "No supported package manager found!"
#     }
# }
#
# # Update Mise
# def update_mise [] {
#     print_section "Updating Mise Packages ðŸ“¦"
#     if !(which mise) { echo "âš ï¸ mise not installed - Skipping!"; return }
#
#     if (confirm_step "Update mise packages?") {
#         env MISE_NODE_COMPILE=false MISE_PYTHON_COMPILE=false {
#             mise self-update
#             mise upgrade
#         }
#         eval (mise activate bash)
#     }
# }
#
# # Update dotfiles
# def update_dotfiles [] {
#     print_section "Updating Dotfiles ðŸ› ï¸"
#     if !(which ansible-pull) { echo "âš ï¸ Ansible-pull not installed - Skipping!"; return }
#
#     if (confirm_step "Update dotfiles via Ansible?") {
#         ansible-pull -U https://github.com/ll-nick/ansible-config.git
#     }
# }
#
# # Update Tmux Plugins
# def update_tmux [] {
#     print_section "Updating Tmux Plugins ðŸ”§"
#     let tpm_dir = $env.HOME + "/.config/tmux/plugins/tpm"
#     if !(path $tpm_dir | exists) { echo "âš ï¸ Tmux Plugin Manager (TPM) Not Found - Skipping!"; return }
#
#     if (confirm_step "Update Tmux plugins?") {
#         ($tpm_dir + "/bin/update_plugins") all
#     }
# }
#
# # Update Neovim Plugins
# def update_neovim [] {
#     print_section "Updating Neovim Plugins âœ¨"
#     if !(which nvim) { echo "âš ï¸ Neovim Not Found - Skipping!"; return }
#
#     if (confirm_step "Update Neovim plugins and commit lazy-lock.json?") {
#         nvim --headless "+Lazy! sync" +qa
#         cd ($env.HOME + "/.config/nvim") {
#             git add lazy-lock.json
#             git commit -m "Version bump"
#             echo "\nChanges:"
#             git diff --staged
#             if (confirm_step "Push changes to remote?") { git push }
#         }
#         return
#     }
#
#     if (confirm_step "Restore Neovim plugins from lazy-lock.json?") {
#         nvim --headless "+Lazy! restore" +qa
#     }
# }
#
# # Update Flatpak Packages
# def update_flatpak [] {
#     print_section "Updating Flatpak Packages ðŸ“¦"
#     if !(which flatpak) { echo "âš ï¸ Flatpak not installed - Skipping!"; return }
#
#     if (confirm_step "Update all Flatpak packages?") {
#         flatpak update -y
#     }
# }
#
# Update all
def update_all [] {
    print_title
    # update_system
    # update_mise
    # update_dotfiles
    # update_tmux
    # update_neovim
    # update_flatpak
    #
    mkdir ($UPDATE_TIMESTAMP | path dirname)
    (date now | format date "%s") | save --force $UPDATE_TIMESTAMP

    print_section "âœ… All Updates Completed!"
}

def "main check" [] {
    update_reminder
}

def "main update" [] {
    update_all
}

def main [] {}

# vim: set ft=nu

